<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on z2w_mose</title>
    <link>http://blog.zhaoziwen.com.cn/post/</link>
    <description>Recent content in Posts on z2w_mose</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.</copyright>
    <lastBuildDate>Tue, 19 Mar 2019 01:01:23 +0800</lastBuildDate>
    
	<atom:link href="http://blog.zhaoziwen.com.cn/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Edit Distance 编辑距离</title>
      <link>http://blog.zhaoziwen.com.cn/post/edit_distance/</link>
      <pubDate>Tue, 19 Mar 2019 01:01:23 +0800</pubDate>
      
      <guid>http://blog.zhaoziwen.com.cn/post/edit_distance/</guid>
      <description>[LeetCode] 72. Edit Distance
Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2
You have the following 3 operations permitted on a word:
 Insert a character Delete a character Replace a character  Example:
Input: word1 = &amp;ldquo;horse&amp;rdquo;, word2 = &amp;ldquo;ros&amp;rdquo;
Output: 3
Explanation:
horse -&amp;gt; rorse
rorse -&amp;gt; rose
rose -&amp;gt; ros
[Edit Distance]: https://leetcode.com/problems/edit-distance
 这道题一开始是能想到实用动态规划的，但是题目理解有点问题，所以没能推出DP的初始状态和状态转移方程。
思路：</description>
    </item>
    
    <item>
      <title>Longest_valid_parentheses</title>
      <link>http://blog.zhaoziwen.com.cn/post/longest_valid_parentheses/</link>
      <pubDate>Wed, 13 Mar 2019 23:58:12 +0800</pubDate>
      
      <guid>http://blog.zhaoziwen.com.cn/post/longest_valid_parentheses/</guid>
      <description>[LeetCode] 32. Longest Valid Parentheses
Given a string containing just the characters &amp;lsquo;(&amp;rsquo; and &amp;lsquo;)&amp;rsquo;, find the length of the longest valid parentheses substring.
Example:
Input: &amp;ldquo;)()()&amp;rdquo;
Output: 4
 思路一：动态规划
dp[i]表示以当前位置为终点的最长长度，则只能在“)”处更新：
如果s[i-1-dp[i-1]]==&amp;lsquo;(&amp;lsquo;，则说明当前位置可以和i-1-dp[i-1]位置匹配，dp[i] = dp[i-1]+2；
然后还要加上匹配位置之前的最长长度dp[i]+=dp[i-dp[i]]；
classSolution { public: int longestValidParentheses(string s) { int result = 0; s = &amp;#39;)&amp;#39; + s; vector&amp;lt;int&amp;gt; dp(s.length(),0); for(int i = 1; i &amp;lt; s.length(); i++) { if(s[i] == &amp;#39;)&amp;#39;) { if(s[i - 1 - dp[i - 1]] == &amp;#39;(&amp;#39;) dp[i] = dp[i-1] + 2; dp[i] += dp[i-dp[i]]; } result = max(result,dp[i]); } return result; } };  思路二：栈</description>
    </item>
    
    <item>
      <title>递归之生成括号</title>
      <link>http://blog.zhaoziwen.com.cn/post/generate_parentheses/</link>
      <pubDate>Tue, 12 Mar 2019 23:48:48 +0800</pubDate>
      
      <guid>http://blog.zhaoziwen.com.cn/post/generate_parentheses/</guid>
      <description>[LeetCode] 22. Generate Parentheses
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
For example, given n = 3, a solution set is:
[
​ &amp;ldquo;((()))&amp;rdquo;
​ &amp;ldquo;(()())&amp;rdquo;
​ &amp;ldquo;()(())&amp;rdquo;
​ &amp;ldquo;()()()&amp;rdquo;
]
 和合法的情况下，任意时刻，左括号个数要大于等于右括号个数
1、当left个数大于right个数，非常情况，返回即可
2、left和right都等于0，临时变量中左右括号个数相等，所以将临时变量的值存入res中
3、其余情况下，先放左括号，再放右括号，然后递归。
classSolution { public: vector&amp;lt;string&amp;gt; generateParenthesis(int n) { vector&amp;lt;string&amp;gt; res; generateParenthesisDFS(n, n, &amp;#34;&amp;#34;, res); return res; } void generateParenthesisDFS(int left, int right, string out, vector&amp;lt;string&amp;gt; &amp;amp;res) { if(left &amp;gt; right) return; if(left == 0 &amp;amp;&amp;amp; right == 0) res.</description>
    </item>
    
    <item>
      <title>Median_of_two_sorted_arrays</title>
      <link>http://blog.zhaoziwen.com.cn/post/median_of_two_sorted_arrays/</link>
      <pubDate>Mon, 11 Mar 2019 21:51:00 +0800</pubDate>
      
      <guid>http://blog.zhaoziwen.com.cn/post/median_of_two_sorted_arrays/</guid>
      <description>Median of two sorted arrays 核心是将原问题转变成寻找第k小数的问题（假设两个原序列升序排列）
首先假设数组A和B的元素个数都大于k/2，比较A[k/2-1]和B[k/2-1]两个元素，这两个元素分别表示A的第k/2小的元素和B的第k/2小的元素。
1、A[k/2-1]&amp;lt;B[k/2-1]，表示A[0]到A[k/2-1]的元素都在A和B合并之后的前k小的元素中，所以我们抛弃它。
2、A[k/2-1]&amp;gt;B[k/2-1]，同上
3、A[k/2-1]=B[k/2-1]，这个数即第K小的数
 [LeetCode] 4. Median of Two Sorted Arrays
There are two sorted arrays nums1 and nums2 of size m and n respectively.
Find the median of the two sorted arrays. The overall run time complexity should be O(log(m+n)).
Example:
nums1 = [1, 3]
nums2 = [2]
The midian is 2.0
 classSolution { public: double findMedianSortedArrays(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) { int m = nums1.</description>
    </item>
    
    <item>
      <title>String_rotate</title>
      <link>http://blog.zhaoziwen.com.cn/post/string_rotate/</link>
      <pubDate>Sun, 10 Mar 2019 15:39:15 +0800</pubDate>
      
      <guid>http://blog.zhaoziwen.com.cn/post/string_rotate/</guid>
      <description>字符串翻转与旋转 翻转 除了常规思路的左右位置对调，至此提供一种新的思路，用以解决其他特定环境下的相关问题。
利用迭代的思路对需要处理的字符串两边整体对换直到只有一位，如对于一个8位数字abcdefgh来讲，处理过程如下：
abcdefgh -&amp;gt; efghabcd -&amp;gt; ghefcdab -&amp;gt; hgfedcba
例如：
 [LeetCode] 190. Reverse Bits
Reverse bits of a given 32 bits unsigned integer.
Example :
Input: 00000010100101000001111010011100
Output: 00111001011110000010100101000000
 常规思路：
classSolution { public: uint32_t res = 0; for (int i = 0; i &amp;lt; 32; i++) { res |= (((n &amp;gt;&amp;gt; i) &amp;amp; 1) &amp;lt;&amp;lt; (32 - i)); } return res; }  本文思路：
classSolution { public: uint32_t reverseBits(uint32_t n) { n = (n &amp;gt;&amp;gt; 16) | (n &amp;lt;&amp;lt; 16); n = ((n &amp;amp; 0xff00ff00) &amp;gt;&amp;gt; 8) | ((n &amp;amp; 0x00ff00ff) &amp;lt;&amp;lt; 8); n = ((n &amp;amp; 0xf0f0f0f0) &amp;gt;&amp;gt; 4) | ((n &amp;amp; 0x0f0f0f0f) &amp;lt;&amp;lt; 4); n = ((n &amp;amp; 0xcccccccc) &amp;gt;&amp;gt; 2) | ((n &amp;amp; 0x33333333) &amp;lt;&amp;lt; 2); n = ((n &amp;amp; 0xaaaaaaaa) &amp;gt;&amp;gt; 1) | ((n &amp;amp; 0x55555555) &amp;lt;&amp;lt; 1); return n; } };  旋转 类似翻转字符串的方法，思路是先把前n-k个字符翻转一下，再把后k个字符翻转一下，最后再把整个数组翻转一下</description>
    </item>
    
    <item>
      <title>搭建hugo博客</title>
      <link>http://blog.zhaoziwen.com.cn/post/new_hugo_blog/</link>
      <pubDate>Thu, 07 Mar 2019 18:58:07 +0800</pubDate>
      
      <guid>http://blog.zhaoziwen.com.cn/post/new_hugo_blog/</guid>
      <description>在很久之前就想拥有一个自己的博客，尝试过wordpress，不过可惜没找到一个喜欢的theme，并且由于wordpress不能原生支持markdown。遂放弃，后来又听说了hugo、hexo之类的静态网页不过。刚开始被复杂的生成流程吓尿，所有现在记录一下博客的搭建过程。
本地开发环境 下面将以macOS为例.
本地安装hugo $ brew install hugo $ hugo version # 检查是否安装成功 $ cd ~/Sites $ hugo new site my-blog $ cd my-blog 安装主题 $ cd themes $ git clone https://github.com/laozhu/hugo-nuo 根据需要替换主题目录下static/img里面的图片
配置 参考exampleSite里面的config.toml修改配置文件
baseURL = &amp;#34;http://blog.zhaoziwen.com.cn&amp;#34; languageCode = &amp;#34;en-us&amp;#34; title = &amp;#34;z2w_mose&amp;#34; theme = &amp;#34;hugo-nuo&amp;#34; copyright = &amp;#34;© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.</description>
    </item>
    
    <item>
      <title>Welcome</title>
      <link>http://blog.zhaoziwen.com.cn/post/welcome/</link>
      <pubDate>Wed, 06 Mar 2019 12:36:04 +0800</pubDate>
      
      <guid>http://blog.zhaoziwen.com.cn/post/welcome/</guid>
      <description>Welcome!</description>
    </item>
    
  </channel>
</rss>